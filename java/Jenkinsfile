List archs = ['x86', 'arm']

// parallel task map
Map tasks = [failFast: false]

//mainNode is where the single manifest creation takes place
String mainNodeLabel = "${NODE_LABEL_JAVA} && x86"

for (int i = 0; i < archs.size(); i++){

    String NODE_ARCH = archs[i]

    //Generate the complete label. e.g. "docker && x86"
    String NODE_LABEL = "${NODE_LABEL_JAVA} && ${NODE_ARCH}"
    
    tasks["${NODE_ARCH}"] = { ->
        node("${NODE_LABEL}") {
            multiarchFlow(NODE_ARCH)
        }
    }
}

private_repo_aws = "fury-registry.adminml.com"
private_repo_aws_url = "https://${private_repo_aws}"
private_repo_gcp = "registry.gcp.furycloud.io"
private_repo_gcp_url = "https://${private_repo_gcp}"
testImage = [amd64: "", arm64: ""]
runtimeImage = [amd64: "", arm64: ""]
version = ""
            
//Pipeline starts here
stage("Pipeline") {
    parallel(tasks)
}
node(mainNodeLabel){
    singlearchFlow()
}

//Pipeline send"

//These are steps that do not need to run on ARM.
def singlearchFlow(){
    sh 'echo "Placeholder Code Quality"'

    stage("OSS") {
        sh 'echo "Placeholder OSS"'
    }

    stage("Publish Documentation") {
        sh 'echo "Placeholder publish documentation"'
    }

    stage("Create single manifest") {
        parallel([
            "AWS Docker Registry": {
                sh "DOCKER_CLI_EXPERIMENTAL=enabled docker manifest create ${private_repo_aws}/${version} --amend ${private_repo_aws}/${runtimeImage['amd64'].imageName()} --amend ${private_repo_aws}/${runtimeImage['arm64'].imageName()}"
            },
            "GCP Docker Registry": {
                sh "DOCKER_CLI_EXPERIMENTAL=enabled docker manifest create ${private_repo_gcp}/${version} --amend ${private_repo_gcp}/${runtimeImage['amd64'].imageName()} --amend ${private_repo_gcp}/${runtimeImage['arm64'].imageName()}"
            }
        ])
    }

    stage("Push single manifest"){
        parallel([
            "AWS Docker Registry": {
                echo "Pushing manifest to AWS Docker Registry..."
                sh "DOCKER_CLI_EXPERIMENTAL=enabled docker manifest push ${private_repo_aws}/${version}"
                echo "Docker manifest successfully pushed to AWS Docker Registry"
            },
            "GCP Docker Registry": {
                echo "Pushing manifest to GCP Docker Registry..."
                sh "DOCKER_CLI_EXPERIMENTAL=enabled docker manifest push ${private_repo_gcp}/${version}"
                echo "Docker manifest successfully pushed to GCP Docker Registry"
            }
        ])
    }
}

def multiarchFlow(architecture) {

    if (architecture == "x86"){
        //Store the x86 node running this pipeline to run single architecture stages later.
        echo "Main node label: ${env.NODE_NAME}"
        mainNodeLabel = env.NODE_NAME

        //Replace with the proper name for docker
        architecture = "amd64"
    }
    else{
        //Replace with the proper name for docker
        architecture = "arm64"
    }

    // Constants
    timeoutUnit = 'MINUTES'

    parameters {
        text(name: 'BUILD_CONTEXT')
    }

    // Build Context
    ctx = readJSON text: "${params.BUILD_CONTEXT}"
    
    stage('Download tooling') {
        sh 'wget -O rp https://s3.amazonaws.com/docker-images-utils/bin/release-process/rp-latest && mv rp /bin && chmod a+x /bin/rp'
    }

    // Clone repo
    stage('Checkout') {
        deleteDir()
        checkout poll: false, scm: [$class: 'GitSCM', branches: [[name: "${ctx.git_commit}"]], doGenerateSubmoduleConfigurations: false, extensions: [[$class: 'CloneOption', depth: 0, noTags: false, reference: '', shallow: true], [$class: 'SubmoduleOption', parentCredentials: false, disableSubmodules: false, recursiveSubmodules: true, reference: '', trackingSubmodules: false]], submoduleCfg: [], userRemoteConfigs: [[credentialsId: 'github-repo-key', name: 'origin', refspec: '+refs/heads/*:refs/remotes/origin/* +refs/pull/*:refs/remotes/origin/pr/*', url: "git@github.com:mercadolibre/${ctx.git_repository_name}.git"]]]
    }

    miniFlow(ctx, architecture)
}

def miniFlow(ctx, architecture) {

    def outputDir = "/data/output/${JOB_NAME}/${BUILD_NUMBER}/output"

    // Set description based on context (either PR for CI or Version for Build)
    if (ctx.build) {
        currentBuild.description = "Version: ${ctx.build_version} - Branch: ${ctx.git_branch} - Commit: ${ctx.git_commit}"
    } else {
        currentBuild.description = "PR #${ctx.git_pr_number} - ${ctx.git_pr_link}"
    }

    try {
        stage("Build Environment") {
            sh "mkdir -p ${outputDir}"
        }

        // Build docker image
        stage('Build Docker Image') {
            timeout(time: 15, unit: timeoutUnit) {
                testImage[architecture] = docker.image("${JOB_NAME}-${BUILD_NUMBER}--${architecture}")
                    
                sh "docker build -t ${testImage[architecture].imageName()} --build-arg ARCH=${architecture} ." 
                
            }
        }

        if (ctx.build && !ctx.build_version.isEmpty()) {
            version = "${JOB_NAME}:${ctx.build_version}"

            //this stage when should not run tests
            shouldRunTestNodes = ctx.test

            if (!shouldRunTestNodes) {
                testImage[architecture].inside("--privileged -v /bin/rp:/bin/rp -v ${outputDir}:/output -e CI_CONTEXT=push -e APPLICATION=${JOB_NAME} -e APP_VERSION=${ctx.build_version}") {
                    if (sh(
                            script: '[ -e "/core/check_dependencies.sh" ] && echo 1 || echo 0',
                            returnStdout: true
                    ).trim() == '1') {
                        stage("Install dependencies") {
                            sh 'cp -fr . /app'
                            timeout(time: 10, unit: timeoutUnit) {
                                runDependenciesCatalogVerification("web")
                            }
                        }
                    }
                }
            }


            stage('Build') {
                shell(stepName: "Create build artifacts output directory", script: "mkdir -p output")

                testImage[architecture].inside("--privileged -v /bin/rp:/bin/rp -v ${outputDir}:/output -e CI_CONTEXT=push -e APPLICATION=${JOB_NAME} -e APP_VERSION=${ctx.build_version}") {
                    def commandsFolder = "${WORKSPACE}/commands"
                    if (fileExists(commandsFolder)) {
                        sh "cp -R ${commandsFolder}/. /commands"
                    }

                    sh "chmod a+x /commands/*"
                    sh "cp -R ${WORKSPACE}/. /app"

                    sh "cp /app/Dockerfile.runtime /output/"
                    timeout(time: 30, unit: timeoutUnit) {
                        sh "cd /app && /core/package.sh"
                    }
                }

                runtimeImage[architecture] = docker.image("${version}--${architecture}")    
                sh "docker build -t ${runtimeImage[architecture].imageName()} --build-arg ARCH=${architecture} --no-cache -f ${outputDir}/Dockerfile.runtime ${outputDir}" 
                
            }
            stage("Publish to registries") {
                parallel([
                    "Push to AWS Docker Registry": {
                        echo "Pushing to AWS Docker Registry..."
                        docker.withRegistry(private_repo_aws_url) {
                            runtimeImage[architecture].push()
                        }
                        echo "Docker image successfully pushed to AWS Docker Registry"
                    },
                    "Push to GCP Docker Registry": {
                        docker.withRegistry(private_repo_gcp_url) {
                            try {
                                echo "Pushing to GCP..."
                                runtimeImage[architecture].push()
                                echo "Docker image successfully pushed to GCP"
                            } catch (error) {
                                echo "Push to GCP failed. Will try again"
                                retry(2) {
                                    runtimeImage[architecture].push()
                                }
                            }
                        }
                    }
                ])
            }
        }
    }
    catch (exception) {
        echo "Oops! Something went wrong"
        throw exception
    }
    finally {
        stage("Cleanup") {
            sh "rm -rf ${outputDir}"
        }
    }
}